\chapter{Coding}

Gödel's original proof of the first incompleteness theorem, 
as detailed in \cite{godel1931formal}, 
involves a crucial step where statements about a formal system are mapped onto statements that 
exist within that system itself. 
This mapping gives rise to the development of a meta-theory, that is, 
it enables the formal system to make assertions about its own content.

Specifically, in the original paper, symbols, terms and formulas of the formal language are encoded 
as natural numbers, referred to as \textit{Gödel numbers}. 
This encoding is useful because properties of formulas in the language 
— such as being a theorem or not — 
can be analysed by examining the properties of their corresponding Gödel numbers. 
This approach leads to the formulation of a formula that effectively says, 
"formula $\phi$ is provable within the system", which applies to any formula $\phi$ in the language.

For HF, we adopt a similar strategy by encoding symbols, terms, and formulas 
as constant terms within the language itself. Why choose constant terms?
Firstly, we want to apply set-theoretical formulas to these codes, 
so it is important that each code corresponds naturally to a set. 
Additionally, as demonstrated in the proof of Gödel’s Diagonal Lemma (discussed in Chapter 6), 
we must be able to encode a code itself. 
This means assigning a code to the code $\ulcorner{\varphi}\urcorner$ of an 
$\mathcal{L}$-formula $\varphi$. 
To achieve this, the codes must be objects within the language $\mathcal{L}$. 
Constant terms are the simplest objects in the language that are naturally associated with sets, 
making them the ideal choice for codes.

However, we want the mapping from objects in the language to their codes to be one-to-one.
Therefore we restrict the codes to a certain family of constant terms, denoted by $\Gamma$.

\begin{definition}
    \lean{HF.C.IsInΓ0, HF.C.IsInΓ, HF.Code}
    \label{def:C.IsInΓ0+C.IsInΓ+Code}
    \leanok
    \uses{def:Lang, def:C}
    We denote by $\Gamma_0$ the least family of constant terms such that
    \begin{enumerate}
        \item $\varnothing \in \Gamma_0$.
        \item If $\sigma \in \Gamma_0$, then $\sigma \lhd \sigma \in \Gamma_0$.
    \end{enumerate}
    Furthermore, we denote by $\Gamma$ the least family of constant terms such that
    $\Gamma_0 \subseteq \Gamma$ and 
    \begin{enumerate}\setcounter{enumi}{2} %does not work in web
        \item If $\sigma, \tau \in \Gamma$, then $\langle\sigma, \tau\rangle \in \Gamma$.
    \end{enumerate}
\end{definition}

\begin{theorem}
    \lean{HF.C.ne_of_isInΓ_and_distinct}
    \label{thm:C.ne_of_isInΓ_and_distinct}
    \leanok
    \uses{def:C, def:IsInΓ0+IsInΓ+Code}
    Let $\sigma, \tau \in \Gamma$ be distinct constant terms, i.e. they are different strings of
    symbols. Then $\vdash \sigma \neq \tau$.
\end{theorem}

\begin{proof}
    Under construction.
\end{proof}

In the following definitions, $\langle \sigma, \tau, \mu \rangle$ is a shorthand for the ordered
pair $\langle \langle \sigma, \tau \rangle, \mu \rangle$,
$\langle \sigma, \tau, \mu, \nu \rangle$ is a shorthand for 
$\langle \langle \sigma, \tau, \mu \rangle, \nu \rangle$, and so on.

\begin{definition}[Coding of symbols]
    \lean{HF.Code.Mem, HF.Code.Enlarge, HF.Code.Eq, HF.Code.Or, HF.Code.Neg, HF.Code.Ex}
    \label{def:Code.Symbols}
    \leanok
    \uses{def:IsInΓ0+IsInΓ+Code}
    We begin by assigning to each symbol of the language a unique code, denoted by
    $\ulcorner \cdot\urcorner$
    In particular, these are the following constant terms belonging to $\Gamma$:
    $$
    \begin{aligned}
    \ulcorner{\varnothing}\urcorner & =\varnothing, \\
    \ulcorner{\in}\urcorner & =\langle \varnothing,\varnothing\rangle, \\
    \ulcorner{\lhd}\urcorner & =\langle \varnothing,\varnothing,\varnothing\rangle, \\
    \ulcorner{=}\urcorner & =\langle \varnothing,\varnothing,\varnothing,\varnothing\rangle, \\
    \ulcorner{\lor}\urcorner & =
    \langle \varnothing,\varnothing,\varnothing,\varnothing,\varnothing\rangle, \\
    \ulcorner{\neg}\urcorner & =
    \langle \varnothing,\varnothing,\varnothing,\varnothing,\varnothing,\varnothing\rangle, \\
    \ulcorner{\exists}\urcorner & =
    \langle \varnothing,\varnothing,\varnothing,\varnothing,\varnothing,\varnothing,
    \varnothing\rangle,\\
    \ulcorner{x_1}\urcorner & = \varnothing \lhd \varnothing, \quad 
    \ulcorner{x_2}\urcorner = \ulcorner{x_1}\urcorner \lhd \ulcorner{x_1}\urcorner,\quad\ldots\quad,
    \ulcorner{x_{k+1}}\urcorner = \ulcorner{x_k}\urcorner \lhd \ulcorner{x_k}\urcorner.
    \end{aligned}
    $$
\end{definition}

\begin{definition}[Coding of terms]
    \lean{HF.Code.Term}
    \label{def:Code.Term}
    \leanok
    \uses{def:IsInΓ0+IsInΓ+Code, def:Code.Symbols}
    The terms $\varnothing$ and $x_k$ have been code already. 
    The remaining case follows the inductive definition
    $$
    \ulcorner{\sigma \lhd \tau}\urcorner = 
    \langle\ulcorner{\lhd}\urcorner, \ulcorner{\sigma}\urcorner, \ulcorner{\tau}\urcorner \rangle.
    $$
\end{definition}

\begin{definition}[Coding of formulas]
    \lean{HF.Code.Formula}
    \label{def:Code.Formula}
    \leanok
    \uses{def:IsInΓ0+IsInΓ+Code, def:Code.Symbols, def:Code.Term}
    Given terms $\sigma, \tau$, the codes of atomic formulas are
    $$
    \ulcorner{\sigma = \tau}\urcorner = 
    \langle\ulcorner{=}\urcorner, \ulcorner{\sigma}\urcorner, \ulcorner{\tau}\urcorner \rangle
    \quad \text{and} \quad
    \ulcorner{\sigma \in \tau}\urcorner = 
    \langle\ulcorner{\in}\urcorner, \ulcorner{\sigma}\urcorner, \ulcorner{\tau}\urcorner \rangle.
    $$
    Non-atomic formulas follow the inductive definition
    $$
    \begin{aligned}
        \ulcorner{\neg\varphi}\urcorner & = 
        \langle\ulcorner{\neg}\urcorner, \ulcorner{\varphi}\urcorner \rangle, \\
        \ulcorner{\varphi \lor \psi}\urcorner & = 
        \langle\ulcorner{\lor}\urcorner, \ulcorner{\varphi}\urcorner, 
        \ulcorner{\psi}\urcorner \rangle, \\
        \ulcorner{\exists x_k \varphi}\urcorner & = 
        \langle\ulcorner{\exists}\urcorner, \ulcorner{x_k}\urcorner, 
        \ulcorner{\varphi}\urcorner \rangle.
    \end{aligned}
    $$
\end{definition}

